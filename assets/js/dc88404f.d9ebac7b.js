"use strict";(self.webpackChunkneo_4_jperf_guide=self.webpackChunkneo_4_jperf_guide||[]).push([[217],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var o=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,i=function(e,t){if(null==e)return{};var r,o,i={},n=Object.keys(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=o.createContext({}),p=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(r),d=i,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||n;return r?o.createElement(h,a(a({ref:t},u),{},{components:r})):o.createElement(h,a({ref:t},u))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,a=new Array(n);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var p=2;p<n;p++)a[p]=r[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,r)}m.displayName="MDXCreateElement"},500:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>n,metadata:()=>s,toc:()=>p});var o=r(7462),i=(r(7294),r(3905));const n={title:"Import data",sidebar_label:"Import data",slug:"/neo4j-slow-import-data-performance"},a=void 0,s={unversionedId:"import-data",id:"import-data",title:"Import data",description:"Executing wast amounts of transactions in a small time frame can be an interesting engineering challenge. One example of this activity is importing huge amounts of data into the Neo4j graph database. Importing data in the Neo4j graph database can come with some performance difficulties. Let's explore a few issues and how to handle them.",source:"@site/docs/import-data.md",sourceDirName:".",slug:"/neo4j-slow-import-data-performance",permalink:"/neo4j-slow-import-data-performance",draft:!1,tags:[],version:"current",frontMatter:{title:"Import data",sidebar_label:"Import data",slug:"/neo4j-slow-import-data-performance"},sidebar:"neo4jperf_guide",previous:{title:"Introduction",permalink:"/"},next:{title:"Indexing",permalink:"/neo4j-slow-query-performance-issue"}},l={},p=[{value:"Neo4j slow import data performance issue",id:"neo4j-slow-import-data-performance-issue",level:2},{value:"How to avoid Neo4j slow importing?",id:"how-to-avoid-neo4j-slow-importing",level:2},{value:"Prerequisites for efficient import",id:"prerequisites-for-efficient-import",level:3},{value:"Importing via Cypher query",id:"importing-via-cypher-query",level:3},{value:"Fix Cypher query import",id:"fix-cypher-query-import",level:2},{value:"Admin import tool",id:"admin-import-tool",level:2}],u={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,o.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Executing wast amounts of transactions in a small time frame can be an interesting engineering challenge. One example of this activity is importing huge amounts of data into the Neo4j graph database. Importing data in the Neo4j graph database can come with some performance difficulties. Let's explore a few issues and how to handle them."),(0,i.kt)("h2",{id:"neo4j-slow-import-data-performance-issue"},"Neo4j slow import data performance issue"),(0,i.kt)("p",null,"To visualize the issues and problems users can face with importing some larger chunks of data, take a look at this older issue ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/19386260/neo4j-import-slowing-down"},'"Neo4j import slowing down"'),". If you carefully read these issues, you can notice that the user is trying to import 500 000 nodes via Cypher queries. He has prepared for import following usual steps. The initial Cypher queries take some 15ms, while later slowing to 6000ms. But the fun part is his response to the initial question. After running the Cypher query import for 24 hours, he decided to kill it. Then he ran the java import tool, and everything was imported in 11 seconds. Viola! "),(0,i.kt)("p",null,"This problem paints the picture of what you can run into while importing data in Neo4j database. "),(0,i.kt)("h2",{id:"how-to-avoid-neo4j-slow-importing"},"How to avoid Neo4j slow importing?"),(0,i.kt)("h3",{id:"prerequisites-for-efficient-import"},"Prerequisites for efficient import"),(0,i.kt)("p",null,"To efficiently import data via Cypher/LOAD CSV, ensure that you have created appropriate unique property constraints. The unique constraint will implicitly create indexes for given properties.\nIf you what to create the uniqueness constraint on properties, you can do it this way: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Cypher"},"CREATE CONSTRAINT foobar FOR (node:FooBar) REQUIRE node.id IS UNIQUE\n")),(0,i.kt)("p",null,"This will ensure that, in this case, merging on node ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," property will be efficient, which can impact the duration time of import.  "),(0,i.kt)("h3",{id:"importing-via-cypher-query"},"Importing via Cypher query"),(0,i.kt)("p",null,"Importing via Cypher query can be quite simple and intuitive to try. Once the unique constraints and indexes are in place, you can execute the queries based on some CSV file. Here is the sample: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Cypher"},'LOAD CSV WITH HEADERS FROM "file:///foobar.csv" AS line\nCREATE (node:FooBar {id: toInteger(line.id))\n')),(0,i.kt)("p",null,"LOAD CSV will iterate over CVS and execute the query for each CSV line. Each query transaction will be committed to the database. But don't skip the next two steps. There are more performance benefits to extract. "),(0,i.kt)("h2",{id:"fix-cypher-query-import"},"Fix Cypher query import"),(0,i.kt)("p",null,"Executing Cypher queries line by line is a highway to hell if you have larger quantities of data. Running a Cypher query can slow down your performance because every Cypher query can become a single database transaction, which can bulk up the memory overhead. It would be best if you were careful with any Cypher query import on a large dataset."),(0,i.kt)("p",null,"But there is a way to improve it by using a special Cypher clause, ",(0,i.kt)("inlineCode",{parentName:"p"},"USING PERIODIC COMMIT"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'USING PERIODIC COMMIT 500\nLOAD CSV WITH HEADERS FROM "file:///foobar.csv" AS line\nCREATE (node:FooBar {id: toInteger(line.id))\n')),(0,i.kt)("p",null,"Using periodic commits, Neo4j will build up transactional data and make a smaller number of database commits, improving overall performance. But still, it will have performance issues with the load on big datasets. "),(0,i.kt)("p",null,"There is also an APOC library for importing with periodic commits, you can check it out ",(0,i.kt)("a",{parentName:"p",href:"https://neo4j.com/labs/apoc/4.4/graph-updates/periodic-execution/"},"here"),"."),(0,i.kt)("h2",{id:"admin-import-tool"},"Admin import tool"),(0,i.kt)("p",null,"One more option and only one for loading big datasets is by using the Neo4j admin import tool. The import tool is made to work on batch imports on large datasets, but it is made for import on previously unused databases. If you have a running database, you can load via ",(0,i.kt)("inlineCode",{parentName:"p"},"LOAD CSV,")," but that will be slow, which can be a deal breaker for some. "),(0,i.kt)("p",null,"Anyway, I hope this short guide helps. Feel free to search for more info on Neo4j docs about ",(0,i.kt)("a",{parentName:"p",href:"https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4j-admin-import/"},"Admin import tool"),"."))}c.isMDXComponent=!0}}]);